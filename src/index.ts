import fs from "fs";
import * as t from "proto-parser";

const PROTO_PATH = __dirname + "/proto-examples/";

const typeMap: Record<string, string> = {
  string: "z.string()",
  int32: "z.number()",
  int64: "z.number()",
  bool: "z.boolean()",
  float: "z.number()",
  double: "z.number()",
  bytes: "z.string()",
};

const IdentifierMap: Record<string, string> = {
  "google.protobuf.Timestamp": "z.string()",
};

const responseMap: Record<string, string> = {
  "google.protobuf.Empty": "z.object({})",
};

function transformEnum(enumDef: t.EnumDefinition, outputFile: string): void {
  // append key to file as a comment
  fs.appendFileSync(outputFile, `export const ${enumDef.name} = z.enum([ `);

  if (!enumDef.values) {
    throw new Error("Enum has no values");
  }

  const values = Object.keys(enumDef.values)
    .map((key) => `"${key}"`)
    .join(", ");

  fs.appendFileSync(outputFile, `${values},`);
  fs.appendFileSync(outputFile, `]);\n\n`);
}

function transformMessage(
  message: t.MessageDefinition,
  outputFile: string
): void {
  // append key to file as a comment
  fs.appendFileSync(outputFile, `export const ${message.name} = z.object({`);

  if (!message.fields) {
    throw new Error("Message has no fields");
  }

  Object.values(message.fields).forEach((field) => {
    if (!field.type) {
      throw new Error("Field has no type");
    }

    const name = field?.options?.json_name || field.name;

    if (field.type.syntaxType === "BaseType") {
      fs.appendFileSync(
        outputFile,
        `\n  ${name}: ${typeMap[field.type.value]},`
      );
    }

    if (field.type.syntaxType === "Identifier") {
      const type = IdentifierMap[field.type.value] || field.type.value;
      fs.appendFileSync(outputFile, `\n  ${name}: ${type},`);
    }
  });

  fs.appendFileSync(outputFile, `\n});\n\n`);
}

function transformService(
  service: t.ServiceDefinition,
  outputFile: string
): void {
  // append key to file as a comment
  fs.appendFileSync(outputFile, `// ${service.name} Service\n`);
  fs.appendFileSync(
    outputFile,
    `export const ${service.name}Contract = c.router({`
  );

  Object.values(service.methods).forEach((method) => {
    if (!method.requestType || !method.responseType) {
      throw new Error("Method has no request or response type");
    }

    const methodAndPath = (() => {
      const getMethod = method.options?.["(google.api.http).get"];
      const postMethod = method.options?.["(google.api.http).post"];
      const deleteMethod = method.options?.["(google.api.http).delete"];

      const response =
        responseMap[method.responseType.value] || method.responseType.value;

      if (getMethod) {
        return `{
    method: "GET",
    path: "${getMethod}",
    query: ${method.requestType.value},
    responses: {
      200: ${response}
    },
  }`;
      } else if (postMethod) {
        return `{
    method: "POST",
    path: "${postMethod}",
    body: ${method.requestType.value},
    responses: {
      200: ${response}
    },
  }`;
      } else if (deleteMethod) {
        return `{
    method: "DELETE",
    path: "${deleteMethod}",
    body: ${method.requestType.value},
    responses: {
      200: ${response}
    },
  }`;
      } else {
        throw new Error(`Unknown method type for ${method.options}`);
      }
    })();

    fs.appendFileSync(outputFile, `\n ${method.name}: ${methodAndPath},`);
  });

  fs.appendFileSync(outputFile, `\n});\n\n`);
}

function main() {
  // read files from given path
  const files = fs.readdirSync(PROTO_PATH);

  files.forEach((file) => {
    const outputFile = PROTO_PATH + file.replace(".proto", ".ts");

    // write a generated comment to file
    fs.writeFileSync(outputFile, "// Generated by proto-gen-ts-rest\n\n");

    // import ts-rest
    fs.appendFileSync(
      outputFile,
      `import { initContract } from "@ts-rest/core";\n
import { z } from "zod";

const c = initContract();`
    );

    // read file content
    fs.readFile(PROTO_PATH + file, "utf8", (err, content) => {
      if (err) {
        console.log(err);
        return;
      }

      const protoDocument = t.parse(content) as t.ProtoDocument;

      if (protoDocument.root?.nested) {
        Object.values(protoDocument.root.nested).forEach((ns) => {
          if (ns.syntaxType === "NamespaceDefinition") {
            if (ns.nested) {
              Object.values(ns.nested).forEach((data) => {
                if (data.syntaxType === "EnumDefinition") {
                  transformEnum(data as t.EnumDefinition, outputFile);
                }

                if (data.syntaxType === "MessageDefinition") {
                  transformMessage(data as t.MessageDefinition, outputFile);
                }

                if (data.syntaxType === "ServiceDefinition") {
                  transformService(data as t.ServiceDefinition, outputFile);
                }
              });
            }
          }
        });
      }
    });
  });
}

main();
