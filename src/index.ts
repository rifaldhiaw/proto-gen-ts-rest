import fs from "fs";
import * as t from "proto-parser";
import { transformEnum } from "./lib/enum";
import { transformMessage } from "./lib/message";

const PROTO_PATH = __dirname + "/proto-examples/";

const responseMap: Record<string, string> = {
  "google.protobuf.Empty": "z.object({})",
};

function transformService(
  service: t.ServiceDefinition,
  outputFile: string
): void {
  // append key to file as a comment
  fs.appendFileSync(outputFile, `// ${service.name} Service\n`);
  fs.appendFileSync(
    outputFile,
    `export const ${service.name}Contract = c.router({`
  );

  Object.values(service.methods).forEach((method) => {
    if (!method.requestType || !method.responseType) {
      throw new Error("Method has no request or response type");
    }

    const methodAndPath = (() => {
      const getMethod = method.options?.["(google.api.http).get"];
      const postMethod = method.options?.["(google.api.http).post"];
      const deleteMethod = method.options?.["(google.api.http).delete"];

      const response =
        responseMap[method.responseType.value] || method.responseType.value;

      if (getMethod) {
        return `{
    method: "GET",
    path: "${getMethod}",
    query: ${method.requestType.value},
    responses: {
      200: ${response}
    },
  }`;
      } else if (postMethod) {
        return `{
    method: "POST",
    path: "${postMethod}",
    body: ${method.requestType.value},
    responses: {
      200: ${response}
    },
  }`;
      } else if (deleteMethod) {
        return `{
    method: "DELETE",
    path: "${deleteMethod}",
    body: ${method.requestType.value},
    responses: {
      200: ${response}
    },
  }`;
      } else {
        throw new Error(`Unknown method type for ${method.options}`);
      }
    })();

    fs.appendFileSync(outputFile, `\n ${method.name}: ${methodAndPath},`);
  });

  fs.appendFileSync(outputFile, `\n});\n\n`);
}

function main() {
  // read files from given path
  const files = fs.readdirSync(PROTO_PATH);

  files.forEach((file) => {
    const outputFile = PROTO_PATH + file.replace(".proto", ".ts");

    // write a generated comment to file
    fs.writeFileSync(outputFile, "// Generated by proto-gen-ts-rest\n\n");

    // import ts-rest
    fs.appendFileSync(
      outputFile,
      `import { initContract } from "@ts-rest/core";\n
import { z } from "zod";

const c = initContract();`
    );

    // read file content
    fs.readFile(PROTO_PATH + file, "utf8", (err, content) => {
      if (err) {
        console.log(err);
        return;
      }

      const protoDocument = t.parse(content) as t.ProtoDocument;

      // write protoDocument to json file
      fs.writeFileSync(
        PROTO_PATH + file.replace(".proto", ".json"),
        JSON.stringify(protoDocument, null, 2)
      );

      if (protoDocument.root?.nested) {
        Object.values(protoDocument.root.nested).forEach((ns) => {
          if (ns.syntaxType === "NamespaceDefinition") {
            if (ns.nested) {
              Object.values(ns.nested).forEach((data) => {
                if (data.syntaxType === "EnumDefinition") {
                  const enumResult = transformEnum(data as t.EnumDefinition);
                  fs.appendFileSync(outputFile, enumResult);
                }

                if (data.syntaxType === "MessageDefinition") {
                  const messageResult = transformMessage(
                    data as t.MessageDefinition
                  );
                  fs.appendFileSync(outputFile, messageResult);
                }

                if (data.syntaxType === "ServiceDefinition") {
                  transformService(data as t.ServiceDefinition, outputFile);
                }
              });
            }
          }
        });
      }
    });
  });
}

main();
